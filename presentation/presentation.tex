%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND THEMES

%----------------------------------------------------------------------------------------

\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{alphabeta}
\usepackage{circuitikz}
\usepackage{hyperref}


\mode<presentation> {

% The Beamer class comes with a number of default slide themes
% which change the colors and layouts of slides. Below this is a list
% of all the themes, uncomment each in turn to see what they look like.


\usetheme{Madrid} 
%\usetheme{Malmoe}
%\usetheme{Marburg}
%\usetheme{Montpellier}
% \usetheme{PaloAlto}


% As well as themes, the Beamer class has a number of color themes
% for any slide theme. Uncomment each of these in turn to see how it
% changes the colors of your current slide theme.

%\usecolortheme{albatross}
%\usecolortheme{beaver}
%\usecolortheme{beetle}
%\usecolortheme{crane}
%\usecolortheme{dolphin}
%\usecolortheme{dove}
%\usecolortheme{fly}
%\usecolortheme{lily}
%\usecolortheme{orchid}
%\usecolortheme{rose}
%\usecolortheme{seagull}
%\usecolortheme{seahorse}
%\usecolortheme{whale}
%\usecolortheme{wolverine}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

%\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}

% Two senses of "proof"
% Formal applies to paper too, "mechanized" is better
% amit's question, does the superfluousness of some equations mean that the SNARK construction can be simplified (no). What are the tradeoffs of eliminating these equations before simplification?
% What is the difference between the extractor in an interactive proof and the extractor here (answer in the interactive proof we have rewinding, but here we use the AGM)
% What are the other cryptographic assumptions
% Venn diagram of SNARKs
% TODO latex sections

% amiller: A good motivating example of "Why bother with this?" beyond the complexity of snark applications is the three or so examples where a soundness bug was introduced, there's the parno paper unsoundness of vntinyram, there's the most famous bug that was left in ZCash for a year or so, affecting the same paper but it's an entirely separate bug
% more lean examples would be really good, there was 1 or 2 slides on it basically but i think there's an interesting segment of the audience that is maybe, devs who know of snarks and are comfortable programming but are unfamiliar with lean, showing some more stepping stone examples of what's involved  would probably be appreciated by them

\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Formal SNARKs Project]{Formal SNARKs Project} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{Bolton Bailey, Andrew Miller} % Your name
\institute[UIUC] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
University of Illinois Urbana-Champaign \\ % Your institution for the title page
\medskip
\textit{boltonb2@illinois.edu} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}



\begin{frame}

    \frametitle{SNARKs give us Efficiently Verifiable Computation}

    What is a SNARK?
    \begin{center}
        \textcolor{olive}{Succinct}, \textcolor{blue}{Noninteractive}, \textcolor{purple}{Argument of Knowledge}       
    \end{center}

    In other words:

    \begin{center}
        A \textcolor{olive}{short ($\approx$200 Byte)}, \textcolor{blue}{single message}, that \textcolor{purple}{proves something is true}        
    \end{center}

    Many potential uses in cryptography:

    \begin{itemize}
        \item Securing privacy in blockchains
        \item Receipt-free voting systems
        \item Verifiable outsourced computation 
    \end{itemize}    

    % TODO redo

\end{frame}


\begin{frame}
    \frametitle{Why Formalize SNARKs in a proof assistant?}
    
    \begin{itemize}
        \item Because implementations in the past have had bugs.
        \begin{itemize}
            \item As Andrew mentioned yesterday, errors were found in an  implementation of the BCTV14 SNARK.
            \item Designing with hindsight in mind this bug would have been caught by mechanizing the proof.
        \end{itemize}
        \item A soundness bug in a SNARK can't necessarily be caught in any other way.
        \item Systematizing proofs can lead to new insights or ways of modifying existing constructions.
        \item Work on a single SNARK can potentially be fit in to larger protocols.
    \end{itemize}

\end{frame}


\begin{frame}
    
    \frametitle{Elliptic Curve Pairings allow Multiplication of CRS Elements}

    We deal with a particular family of SNARKs, which use Elliptic Curve pairings.

    $$ G_1 = \langle g_1 \rangle, G_2 = \langle g_2 \rangle, G_T = \langle g_T \rangle$$

    Everyone starts with \textcolor{blue}{CRS Elements} generated by a third party.

    $$ \textcolor{blue}{g_1, g_1^{\textcolor{blue}{\tau}}, g_1^{\textcolor{blue}{\tau^2}}, g_1^{\textcolor{blue}{\tau^2\beta + \tau^3 \beta}}, g_2^{\textcolor{blue}{\gamma}}, g_2^{\textcolor{blue}{\beta\gamma}}, \ldots}$$

    Individuals can compute products ``in the group exponent'' using the pairing $E$.

    $$ E(\textcolor{blue}{g_1^{\textcolor{blue}{\tau}}g_1^{\textcolor{blue}{\tau^2}}}, \textcolor{blue}{g_2^{\textcolor{blue}{\gamma}}}) 
    = E(\textcolor{blue}{g_1^{\textcolor{blue}{\tau}+\textcolor{blue}{\tau^2}}}, \textcolor{blue}{g_2^{\textcolor{blue}{\gamma}}}) 
    = {g_T^{{(\tau + \tau^2)\gamma}}} $$

    
\end{frame}

\begin{frame}
    
    \frametitle{The Algebraic Group Model}

    We must make some cryptographic assumption to reduce our security properties to.

    We use the \emph{Algebraic Group Model}: Any party can only generate group exponents as linear combinations of exponents in the CRS.

    \begin{center}
        \includegraphics[width=0.9\textwidth]{alicecrs.png}        
    \end{center}

\end{frame}

\begin{frame}
    
    \frametitle{The Algebraic Group Model - Knowledge Extraction}

    \textbf{Completeness:} Alice can prove true statements
    
    % If the $x, w$ is a correct pair according to the circuit, then $\pi \gets \text{Prove}(x, w, CRS)$, then $\text{Verify}(x, \pi, CRS)$ outputs success.

    \textbf{Knowledge Soundness:} If Alice makes a successful proof, she must have known the witness.
    
    % For any adversary generating $x, \pi \gets \text{Adv}$, then either $\text{Verify}(x, \pi, CRS)$ outputs failure, or $x \in L$ (with high probability).

    \begin{center}
        \includegraphics[width=0.9\textwidth]{extraction.png}        
    \end{center}


    The AGM makes proving knowledge soundness simple: We assume that the prover chooses coefficients for all the values she outputs, we can prove these coefficients equal the witness

\end{frame}

\begin{frame}
    
    \frametitle{Putting it all together:}

    A high-level overview of why these protocols are sound:

    \begin{enumerate}
        \item The CRS generator samples random \textcolor{green}{field elements} ($\textcolor{green}{\tau} \dots$).
        \item It uses these to generate \textcolor{blue}{CRS elements} ($\textcolor{blue}{g_1^{\tau}}$).
        \item The Prover makes a few linear combinations of CRS elements and returns these as proof elements.
        \item The Verifier computes some pairings of these proof elements and checks they are equal.
        \item This guarantees that the polynomials over $\tau, \dots$ that the proof elements represent are equal on the CRS generators choice of random field values. By the Schwartz-Zippel lemma, the polynomials themselves are likely to be equal.
    \end{enumerate}



    % Assume Alice only generates group elements as a product of group operations that she performs.
    
    % The proof output that Alice gives must be a linear combination of her initial group elements.
    
    % Charles reconstructs the witness $w$ from this linear combination.

\end{frame}


\begin{frame}
    
    \frametitle{Before we move on to the mechanization ...}

    \begin{center}
        ... any questions?        
    \end{center}

    
    
\end{frame}



\begin{frame}
    \frametitle{Formalizing SNARKs in the Lean Theorem Prover}
    
    For our formalization, we use the Lean Theorem Prover. See our \underline{\href{https://github.com/BoltonBailey/formal_baby_snark}{Github Repo}}. % TODO stylize

    \begin{itemize}
        \item We leverage the \texttt{mathlib} library, which has support for multivariable polynomials and is open for pull requests. 
        \item We write tactics for automating proofs that anyone can then run on their own constructions.
    \end{itemize}

    % TODO add more

\end{frame}

\begin{frame}
    
    \frametitle{The Game Plan for Mechanically Proving Soundness}

    The idea is to create code that can prove soundness essentially entirely automatically.

    \begin{enumerate}
        \item Start by assuming the equalities the verifier checks are true.
        \item We specify an extractor as a function of the coefficients of Alice's linear combination.
        \item Prove that this witness is correct for the circuit and the $x$ value
    \end{enumerate}
    
\end{frame}


\begin{frame}
    \frametitle{An Extremely Simple (not complete) Toy SNARK}

    Let $\textcolor{red}{w} = (\textcolor{red}{A},\textcolor{red}{B}), \textcolor{violet}{x} = (\textcolor{violet}{C},\textcolor{violet}{D},\textcolor{violet}{E})$. Make a SNARK that proves 
    $$(\textcolor{red}{A}  \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} \textcolor{violet}{C}) = \textcolor{violet}{E}$$

    \begin{center}
        \begin{circuitikz} 
            \node (D) at (-2,2-0.3) {$\textcolor{violet}{D}$};
            \node (C) at (-2, -0.3) {$\textcolor{violet}{C}$};
            \node (B) at (-2, +0.3) {$\textcolor{red}{B}$};
            \node (A) at (-2,2+0.3) {$\textcolor{red}{A}$};
            \node (E) at (3,1) {$\textcolor{violet}{E}$};
            \draw
            (0,2) node[and port] (myand1) {}
            (0,0) node[and port] (myand2) {}
            (2,1) node[or port] (myor) {}
            (A) -- (myand1.in 1)
            (D) -- (myand1.in 2)
            (B) -- (myand2.in 1)
            (C) -- (myand2.in 2)
            (myor.out) -- (E)
            (myand1.out) -- (myor.in 1)
            (myand2.out) -- (myor.in 2);
        \end{circuitikz}        
    \end{center}

    Two unknown field elements \texttt{\textcolor{green}{\alpha}, \textcolor{green}{\beta}}

    Three CRS group elements 
    $g^{\texttt{\textcolor{blue}{\alpha}}}, g^{\texttt{\textcolor{blue}{\beta}}}, g^{\texttt{\textcolor{blue}{\alpha\beta}}}$, hereafter just denoted ${\texttt{\textcolor{blue}{\alpha}}}, {\texttt{\textcolor{blue}{\beta}}}, {\texttt{\textcolor{blue}{\alpha\beta}}}$.

    Prover returns 
    (\texttt{\textcolor{red}{A}\textcolor{blue}{\alpha}+\textcolor{red}B\textcolor{blue}{β}})     
    % (\texttt{\textcolor{red}{A}\textcolor{blue}{\alpha}+\textcolor{red}B\textcolor{blue}{β}, \textcolor{violet}C\textcolor{blue}{α}+\textcolor{violet}{D}\textcolor{blue}{β}, \textcolor{violet}{E}\textcolor{blue}{α}\textcolor{blue}{β}})     
    $ \implies $
    Verifier checks \texttt{(\textcolor{red}{A}\textcolor{blue}{\alpha}+\textcolor{red}B\textcolor{blue}{β})(\textcolor{violet}C\textcolor{blue}{α}+\textcolor{violet}{D}\textcolor{blue}{β}) = \textcolor{violet}{E}\textcolor{blue}{α}\textcolor{blue}{β}}  

\end{frame}

\begin{frame}
    \frametitle{Step 0: Load Assumptions and Goal into Lean}

    For any coefficients the adversary generates ...
    $$ 
    \forall 
    \texttt{
    \textcolor{red}{A}
    \textcolor{red}{B}
    \textcolor{violet}{C}
    \textcolor{violet}{D}
    \textcolor{violet}{E}}
    : \mathbb{F}  $$

    Assume the polynomials in $\texttt{\textcolor{blue}{\alpha}, \textcolor{blue}{\beta}}$ are equal (by Schwartz-Zippel):
    $$\texttt{(\textcolor{red}{A} * \textcolor{blue}{\alpha} + \textcolor{red}B * \textcolor{blue}{β})(\textcolor{violet}C * \textcolor{blue}{α} + \textcolor{violet}{D} * \textcolor{blue}{β}) = \textcolor{violet}{E} * \textcolor{blue}{α} * \textcolor{blue}{β}}  $$   

    Goal:
    $$\texttt{(\textcolor{red}{A} * \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} * \textcolor{violet}{C}) = \textcolor{violet}{E}}$$

\end{frame}

\begin{frame}
    \frametitle{Step 1: Isolate Coefficients}

    Old Assumption:
    $$\texttt{(\textcolor{red}{A} * \textcolor{blue}{\alpha} + \textcolor{red}B * \textcolor{blue}{β})(\textcolor{violet}C * \textcolor{blue}{α} + \textcolor{violet}{D} * \textcolor{blue}{β}) = \textcolor{violet}{E} * \textcolor{blue}{α} * \textcolor{blue}{β}}  $$   

    New Assumption:
    $$\texttt{\textcolor{red}{A}*\textcolor{violet}{C} * \textcolor{blue}{\alpha}$^2$ + (\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C) * \textcolor{blue}{α} * \textcolor{blue}{β} + \textcolor{red}B*\textcolor{violet}{D} * \textcolor{blue}{β}$^2$ = \textcolor{violet}{E} * \textcolor{blue}{α} * \textcolor{blue}{β}}  $$   

    Goal:
    $$\texttt{(\textcolor{red}{A} * \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} * \textcolor{violet}{C}) = \textcolor{violet}{E}}$$

\end{frame}

\begin{frame}
    \frametitle{Step 2: Reexpress Polynomial as Equation of Coefficients}

    Old Assumption:
    $$\texttt{\textcolor{red}{A}*\textcolor{violet}{C} * \textcolor{blue}{\alpha}$^2$ + (\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C) * \textcolor{blue}{α} * \textcolor{blue}{β} + (\textcolor{red}B*\textcolor{violet}{D} * \textcolor{blue}{β}$^2$) = \textcolor{violet}{E} * \textcolor{blue}{α} * \textcolor{blue}{β}}  $$    

    New Assumptions:
    $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{C} = 0} $$
    $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C = \textcolor{violet}{E}} $$
    $$ \texttt{\textcolor{red}B*\textcolor{violet}{D} = 0}  $$   

    Goal:
    $$\texttt{(\textcolor{red}{A} * \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} * \textcolor{violet}{C}) = \textcolor{violet}{E}}$$

\end{frame}

\begin{frame}
    \frametitle{Step 3: Recursively Case on Zero Divisors and Simplify}

    Old Assumptions: 
    $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{C} = 0} $$
    $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C = \textcolor{violet}{E}} $$
    $$ \texttt{\textcolor{red}B*\textcolor{violet}{D} = 0}  $$   

    New Assumptions:
    $$ \texttt{\textcolor{red}{A} = 0 or \textcolor{violet}{C} = 0} $$
    $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C = \textcolor{violet}{E}} $$
    $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$   

    Goal:
    $$\texttt{(\textcolor{red}{A} * \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} * \textcolor{violet}{C}) = \textcolor{violet}{E}}$$

\end{frame}

\begin{frame}
    \frametitle{Step 3: Recursively Case on Zero Divisors and Simplify}

    \parbox[t]{5cm}{
    \centering
    Case 1
        $$ \texttt{\textcolor{red}{A} = 0}$$
        $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C = \textcolor{violet}{E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%
    \hspace{1cm}%
    \parbox[t]{5cm}{
    \centering
    Case 2
        $$ \texttt{\textcolor{violet}{C} = 0}$$
        $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C = \textcolor{violet}{E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%


    Goal:
    $$\texttt{(\textcolor{red}{A} * \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} * \textcolor{violet}{C}) = \textcolor{violet}{E}}$$

\end{frame}

\begin{frame}
    \frametitle{Step 3: Recursively Case on Zero Divisors and Simplify}

    \parbox[t]{5cm}{
    \centering
    Case 1
        $$ \texttt{\textcolor{red}{A} = 0}$$
        $$ \texttt{0*\textcolor{violet}{D} + \textcolor{red}{B}*\textcolor{violet}C = \textcolor{violet}{E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%
    \hspace{1cm}%
    \parbox[t]{5cm}{
    \centering
    Case 2
        $$ \texttt{\textcolor{violet}{C} = 0}$$
        $$ \texttt{\textcolor{red}{A}*\textcolor{violet}{D} + \textcolor{red}{B}*0 = \textcolor{violet}{E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%


    Goal:
    $$\texttt{(\textcolor{red}{A} * \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} * \textcolor{violet}{C}) = \textcolor{violet}{E}}$$

\end{frame}

\begin{frame}

    \frametitle{Step 3: Recursively Case on Zero Divisors and Simplify}

    \parbox[t]{5cm}{
    \centering
    Case 1
        $$ \texttt{\textcolor{red}{A} = 0}$$
        $$ \texttt{\textcolor{red}{B} * \textcolor{violet}C = \textcolor{violet}{E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%
    \hspace{1cm}%
    \parbox[t]{5cm}{
    \centering
    Case 2
        $$ \texttt{\textcolor{violet}{C} = 0}$$
        $$ \texttt{\textcolor{red}{A} * \textcolor{violet}{D} = \textcolor{violet}{E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%


    Goal:
    $$\texttt{(\textcolor{red}{A} * \textcolor{violet}{D}) = \textcolor{violet}{E}  \text{ or } (\textcolor{red}{B} * \textcolor{violet}{C}) = \textcolor{violet}{E}}$$

\end{frame}

\begin{frame}

    \frametitle{Step 3: Recursively Case on Zero Divisors and Simplify}

    \parbox[t]{5cm}{
    \centering
    Case 1
        $$ \texttt{\textcolor{red}{A} = 0}$$
        $$ \texttt{\textcolor{blue}{{B} * C = E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%
    \hspace{1cm}%
    \parbox[t]{5cm}{
    \centering
    Case 2
        $$ \texttt{\textcolor{violet}{C} = 0}$$
        $$ \texttt{\textcolor{green}{{A} * D = E}} $$
        $$ \texttt{\textcolor{red}B = 0 or \textcolor{violet}{D} = 0}  $$ }%


    Goal:
    $$\texttt{\textcolor{green}{({A} * {D}) = {E}}  \text{ or } \textcolor{blue}{({B} * {C}) = {E}}}$$
    \begin{center}
        \includegraphics[width=0.2\textwidth]{partypopper.png}        
    \end{center}

\end{frame}

\begin{frame}

    \frametitle{(Sometimes needed) Step 4: Cleanup}

    \begin{itemize}
        \item SNARKs are based on pairings so the preceding polynomials usually have degree 2.
        \item The preceding steps generally close most goals - by design zeros keep popping up. 37 recursive calls is enough for our Groth '16 formalization to solve the whole thing.
        \item ... but usually there are a few critical cases that need to be solved by hand (only 1 in the case of Groth '16).
    \end{itemize}

\end{frame}

\begin{frame}

    \frametitle{Additional Complications: Reappearing Sums}

    In the example 

    $$ \texttt{\textcolor{red}{A}}$$

    In reality:

    $$\texttt{\Sigma (x : fin (n\_var - 1)) in finset.fin\_range (n\_var - 1),}$$
    $$\texttt{  polynomial.X \textasciicircum (x : nat) * t * polynomial.C (C\_h x)} $$

    Luckily, the freedom over $C\_h$ means expressions like these can be treated as atoms.

    We do need to extract CRS-associated polynomial variables out of these sums though.

\end{frame}

\begin{frame}

    \frametitle{Additional Complications: Laurent Polynomials}

    In the example:

    $$ \texttt{\textcolor{red}{A}\textcolor{blue}{\alpha}+\textcolor{red}B\textcolor{blue}{β}} $$

    In reality:

    $$\texttt{\textcolor{red}{A}+\textcolor{red}B\textcolor{blue}{β}/\textcolor{blue}{\alpha}}$$

    These are \textit{Laurent Polynomials} (polynomials with negative exponents) and the literature is full of them.

    \vspace{0.5cm}

    To deal with this, we multiply through by $\texttt{\textcolor{blue}{\alpha}}$, prove this is equivalent to the original theorem, then proceed.

\end{frame}

\begin{frame}
    \frametitle{Six SNARKs Formalized}

    Including

    \begin{itemize}
        \item The original Groth '16 (amenable to more types of pairings)
        \item GGPR
        \item Pinocchio
    \end{itemize}    

    \begin{center}
        \includegraphics[width=0.9\textwidth]{tableofsnarks2.png}        
    \end{center}

\end{frame}

\begin{frame}
    \frametitle{Any bugs?}

    No. But there were some interesting things worth mentioning:

    \begin{center}
        \includegraphics[width=0.9\textwidth]{groth16statement.png}        
    \end{center}
    
    This argument from the Groth '16 paper is a bit confusing - the proof of this statement from Baghery et al. is much longer and involves casework.

    \begin{center}
        \includegraphics[width=0.9\textwidth]{lipmaatable.png}        
    \end{center}

    This table from Lipmaa dangerously trusts this clause (luckily, due to a happy coincidence, that SNARK seems to still be sound).
    
\end{frame}

% \begin{frame}
%     \frametitle{Formal Proof Stack}

%     \begin{itemize}
%         \item Cairo is an interesting project: A SNARK-wrapped VM

%         \item Recently completed research of Avigad et al. formalizes the correctness of this VM in Lean (but not the soundness)
    
%         \item Eventually, it might be nice to integrate all of this into one big verification of the entire stack. 
        
%         \item Potentially with modularly-replaceable SNARK layer.
%     \end{itemize}
     
% \end{frame}

% \begin{frame}

%     \frametitle{Performance}

%     As of last night the proof is down to about 
    
%     \begin{itemize}
%         \item 20 seconds for the polynomial normalization.
%         \item 50 seconds for the recursive simplification.
%     \end{itemize}





% \end{frame}

\end{document} 